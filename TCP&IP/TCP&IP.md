# TCP 于 UDP 的区别

## TCP

TCP(Transmission Control Protocol) 是面向连接的、可靠的流协议。流就是不间断的数据结构，可以想象成排水管道中的水流。当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。
TCP 为提供可靠性传输，实行 顺序控制 重发控制。此外还具备 流控制（流量控制） 拥塞控制 提高网络利用率等众多功能

## UDP

UDP(User Datagram Protocol) 是不具有可靠性的数据协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会达到。因此，应用有时会根据自己的需要进行重发处理。

## [三次握手与四次握手](https://hit-alibaba.github.io/interview/basic/network/TCP.html)

### 三次握手

三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。
三次握手的目的时连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

- 第一次握手(SYN=1, seq=x):
  客户端发送一个 TCP 的 SYN 标识位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 x，保存在包头的序列号(Sequence Number)字段里。
  发送完毕后，客户端进入 SYN_SEND 状态。
- 第二次握手(SYN=1, ACK=1, seq=y,ACKnum=x+1):x
  服务器发回确认包(ACK)应答。即 SYN 标识位和 ACK 标识位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 x+1。
  发送完毕后，服务器端进入 SYN_RCVD 状态。
- 第三次握手(ACK=1, ACKnum=y+1)
  客户端再次发送确认包(ACK)，SYN 标识位为 0，ACK 标识位为 1，并且把服务器发来的 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1。
  发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

### 四次挥手

TCP 的连接的拆除需要发送四个包，因此成为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或者服务器端均可主动发起挥手动作。

- 第一次挥手(FIN=1, seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标识位置为 1 的包，标识自己已经没有数据可以发送了，但是仍然可以接收数据。
  发送完毕后，客户端进入 FIN_WAIT_1 状态。

- 第二次挥手(ACK=1, ACKnum=x+1)
  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。
  发送完毕后服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
- 第三次挥手(FIN=1, seq=y)
  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。
  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。
- 第四次挥手(ACK=1, ACKnum=y+1)
  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。
  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
  客户端等待了某个固定时间（两个最大段生命周期， 2MSL， 2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

## 为什么 TCP 关闭连接为什么要四次而不是三次？

服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手。

## 客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？

按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED 状态了，但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。

## HTTPS 中的 TLS 原理

TLS（Transport Layer Security，传输层安全协议）是 HTTPS 的核心安全协议，它提供了三个关键的安全特性：

1. 身份验证：通过数字证书验证服务器的身份，防止中间人攻击
2. 数据加密：确保传输过程中数据的机密性
3. 完整性校验：防止数据在传输过程中被篡改

TLS 握手过程包括以下步骤：

1. 客户端发送 ClientHello 消息，包含支持的 TLS 版本、随机数和支持的加密套件
2. 服务器响应 ServerHello，选择具体的 TLS 版本、加密套件并提供数字证书和随机数
3. 客户端验证证书有效性并生成预主密钥，用服务器公钥加密后发送
4. 双方基于预主密钥和随机数生成相同的主密钥
5. 双方使用主密钥生成 MAC 密钥和对称加密密钥，完成握手

## Cookie、Session 与 LocalStorage 的区别

### Cookie

Cookie 是存储在浏览器端的小型文本文件，由服务器发送给客户端，客户端会将其保存并在后续请求中携带 Cookie 发送给服务器。

特点：

- 存储容量小（通常限制在 4KB 左右）
- 每次请求都会携带在 HTTP 头部中，会增加请求体积
- 可以设置过期时间
- 可以设置作用域（domain、path）
- 支持设置 HttpOnly、Secure、SameSite 等安全属性
- 服务端和客户端都可以操作

应用场景：

- 用户身份认证
- 记住登录状态
- 用户偏好设置

### Session

Session 是存储在服务器端的数据，通过在客户端存储一个 Session ID 来识别对应的服务器端 Session 数据。

特点：

- 数据存储在服务器端，安全性较高
- 无大小限制
- 依赖于 Cookie 或 URL 重写等方式传递 Session ID
- 服务器重启或超时会导致 Session 失效
- 占用服务器内存资源

应用场景：

- 用户登录后的会话管理
- 存储敏感信息
- 购物车数据

### LocalStorage

LocalStorage 是 HTML5 提供的一种 Web 存储方式，数据存储在浏览器端，除非手动清除否则永久有效。

特点：

- 存储容量大（一般为 5MB-10MB）
- 数据只存储在浏览器端，不会随请求发送给服务器
- 数据持久化，除非手动删除否则永久保存
- 同源策略限制（协议、域名、端口相同）
- 只能在客户端操作
- 基于字符串键值对存储

应用场景：

- 缓存静态数据
- 用户配置信息
- 离线数据存储

### 三者对比

| 特性       | Cookie         | Session             | LocalStorage     |
| ---------- | -------------- | ------------------- | ---------------- |
| 存储位置   | 浏览器         | 服务器              | 浏览器           |
| 存储容量   | ~4KB           | 无限制              | ~5-10MB          |
| 生命周期   | 可设置过期时间 | 服务器设置超时      | 永久（手动清除） |
| HTTP 请求  | 每次携带       | 通过 Cookie 传递 ID | 不发送           |
| 安全性     | 较低           | 高                  | 中等             |
| 服务端访问 | 可访问         | 可访问              | 无法访问         |
| 客户端访问 | 可访问         | 通过接口访问        | 可访问           |
