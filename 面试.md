# mobx相关
通过监听数据（对象、数组）的属性变化，可以通过直接在数据上更改就能触发UI的渲染，从而做到MVVM、响应式、上手成本低、开发效率高

mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。

# redux vs mobx
* redux将数据保存在单一的store中；mobx将数据保存在分散的多个store中
* edux使用plain object保存数据，需要手动处理变化后的操作；mobx使用observable保存数据，数据变化后自动处理响应的操作
* redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
* mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
* mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易。

# reducer纯函数操作数组 为什么不push操作 （Immutability）

## 纯函数
* 返回值必须依赖于输入值，且输入值不变，返回值也不会变
* 它不会作出超出它本身作用域的影响

### 超出它本身作用域
* 直接修改数组或者对象的值
* 修改当前函数外的状态, 比如全局变量、window的属性
* API请求
* Math.random()

# React双向绑定

# [React高阶组件](https://juejin.im/post/6844904050236850184)

高阶组件是一个函数，接收一个组件，然后返回一个新的组件

* react高阶组件能够让我们写出更易于维护的react代码
* 优雅地拆分组件
* 抽取重复代码，实现组件复用，常见场景：页面复用
* 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
* 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。