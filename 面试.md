# mobx相关
通过监听数据（对象、数组）的属性变化，可以通过直接在数据上更改就能触发UI的渲染，从而做到MVVM、响应式、上手成本低、开发效率高

mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。

# redux vs mobx
* redux将数据保存在单一的store中；mobx将数据保存在分散的多个store中
* redux使用plain object保存数据，需要手动处理变化后的操作；mobx使用observable保存数据，数据变化后自动处理响应的操作
* redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
* mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
* mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易。

# reducer纯函数操作数组 为什么不push操作 （Immutability）

## 纯函数
* 返回值必须依赖于输入值，且输入值不变，返回值也不会变
* 它不会作出超出它本身作用域的影响

### 超出它本身作用域
* 直接修改数组或者对象的值
* 修改当前函数外的状态, 比如全局变量、window的属性
* API请求
* Math.random()

# React双向绑定

# 为什么每个react组件都需要import React from 'react'
因为打包工具是需要React.createElement这个方法把你写的jsx转化为虚拟DOM

# [React高阶组件](https://juejin.im/post/6844904050236850184)

高阶组件是一个函数，接收一个组件，然后返回一个新的组件

* react高阶组件能够让我们写出更易于维护的react代码
* 优雅地拆分组件
* 抽取重复代码，实现组件复用，常见场景：页面复用
* 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
* 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。

## 解决的问题

* 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合
* 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为
* 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担

# [Hook](https://github.com/brickspert/blog/issues/26)
## 优势
* 减少状态逻辑复用的风险
* 避免地狱式嵌套
* 让组件更容易理解
* 使用函数代替class

# [受控组件](https://reactjs.org/docs/forms.html#controlled-components) vs [非受控组件](https://reactjs.org/docs/uncontrolled-components.html)
受控组件：
在 HTML 中，表单元素（如input、 textarea 和 select）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

非受控组件：要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```
# react取消的三个生命周期函数
componentWillMount componentWillReceiveProps componentWillUpdate 容易被误用并滥用，可能会对异步渲染造成潜在的问题

# [react合成事件](https://juejin.cn/post/6897911576053940231)
react合成事件(SyntheticEvent)是react模拟原生DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。兼容所有浏览器，拥有与原生浏览器原生事件相同的接口

# react Fiber
react内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点

# react组件间的通信方式
* 父组件向子组件通信 -- props传递
* 子组件向父组件通信 -- 父组件传递回调函数给子组件，子组件调用该回调函数，便可以向父组件通信
* 跨级组件之间的通信 -- 层层传递props  使用context对象
* 非嵌套组件间通信 -- 利用二者共同父组件的 context 对象进行通信 使用自定义事件的方式

# [Webpac是什么？解决了什么问题](https://www.bwrong.co/post/dev-tools03/)
Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler），当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
Webpack所指的模块不仅仅是JavaScript中的模块，通过Loader，它可以处理任意类型的资源。广义上来说，在Webpack看来，任意资源都是模块。

## Tree Shaking
它依赖于ES2015中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。
在现代 JavaScript 应用程序中，我们使用模块打包(如webpack或Rollup)将多个 JavaScript 文件打包为单个文件时自动删除未引用的代码。这对于准备预备发布代码的工作非常重要，这样可以使最终文件具有简洁的结构和最小化大小。

# [前端工程化](https://juejin.cn/post/6844903588553048077)


# [DOM节点是如何与CSS样式关联的](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)
* DOM 树与 CSSOM 树合并后形成渲染树。
* 渲染树只包含渲染网页所需的节点。
* 布局计算每个对象的精确位置和大小。
* 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。

## 为构建渲染树，浏览器大体上完成了下列工作：
* 从 DOM 树的根节点开始遍历每个可见节点
    * 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
    * 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。
* 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
* 发射可见节点，连同其内容和计算的样式。

# 为什么es5的var 会是变量提升机制
当栈内存形成，JS代码自上而下执行之前，浏览器首先会把所有带“var”、“function”关键词的进行提前“声明（var）”或“定义（function）”。

# 全局变量的优缺点
优点：
* 全局可见，任何 一个函数或线程都可以读写全局变量-同步操作简单。                            
* 内存地址固定，读写效率比较高。
缺点：
* 全局变量存放在静态存储区，系统需要为其分配内存，一直到程序结束， 才会释放内存，这一点就局部变量的动态分配，随用随从栈中申请，用完（函数调用完毕）就释放。
* 影响函数的封装性能 降低函数的移值性


# JavaScript模块化

## 什么是模块化
优秀的作者把他们的书分成章节，优秀的程序员把他们的程序分成模块。好的模块是高度独立的，具有特定功能的，可以根据需要对它们进行修改，删除或添加，而不会破坏整个系统。

## 模块化的好处
* __命名空间__ 在 JavaScript 中，每个 JS 文件的接口都暴露在全局作用域中，每个人都可以访问它们，并且容易造成命名空间污染。模块化可以为变量创建私有空间来避免命名空间污染。
* __可重用性__ 将此代码模块化，则可以反复使用，且在需要修改时只需要修改此模块，而不需要在项目中的每个此代码处做修改。
* __可维护性__ 模块应该是独立的，一个设计良好的模块应尽可能减少对部分代码库的依赖，从而使其能够独立地删减和修改。当模块与其他代码片段分离时，更新单个模块要容易得多，还可以对每次修改的内容做版本管理。

# [web语义化](https://juejin.im/entry/6844903582274174984)
Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。 简单来说就是利于 SEO，便于阅读维护理解。

* 正确的标签做正确的事情
* 页面内容结构化
* 无CSS样子时也容易阅读，便于阅读维护和理解
* 便于浏览器、搜索引擎解析。 利于爬虫标记、利于SEO


# [三次握手与四次握手](https://hit-alibaba.github.io/interview/basic/network/TCP.html)
## 三次握手
三次握手（Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。
三次握手的目的时连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。
* 第一次握手(SYN=1, seq=x): 
  客户端发送一个TCP的SYN标识位置1的包，指明客户端打算连接的服务器的端口，以及初始序号x，保存在包头的序列号(Sequence Number)字段里。 
  发送完毕后，客户端进入SYN_SEND状态。
* 第二次握手(SYN=1, ACK=1, seq=y,ACKnum=x+1):x
  服务器发回确认包(ACK)应答。即SYN标识位和ACK标识位均为1。服务器端选择自己ISN序列号，放到Seq域里，同时将确认序号(Acknowledgement Number)设置为客户的ISN加1，即x+1。
  发送完毕后，服务器端进入SYN_RCVD状态。
* 第三次握手(ACK=1, ACKnum=y+1)
  客户端再次发送确认包(ACK)，SYN标识位为0，ACK标识位为1，并且把服务器发来的ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。
  发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手结束。


## 四次挥手
  TCP的连接的拆除需要发送四个包，因此成为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或者服务器端均可主动发起挥手动作。
* 第一次挥手(FIN=1, seq=x)
  假设客户端想要关闭连接，客户端发送一个FIN标识位置为1的包，标识自己已经没有数据可以发送了，但是仍然可以接收数据。
  发送完毕后，客户端进入FIN_WAIT_1状态。
* 第二次挥手(ACK=1, ACKnum=x+1)
  服务器端确认客户端的FIN包，发送一个确认包，表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。
  发送完毕后服务器端进入CLOSE_WAIT状态，客户端接收到这个确认包后，进入FIN_WAIT_2状态，等待服务器端关闭连接。
* 第三次挥手(FIN=1, seq=y)
  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN置为1。
  发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。
* 第四次挥手(ACK=1, ACKnum=y+1)
  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待可能出现的要求重传的ACK包。
  服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。
  客户端等待了某个固定时间（两个最大段生命周期， 2MSL， 2 Maximum Segment Lifetime）之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。


## 为什么 TCP 关闭连接为什么要四次而不是三次？
服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段，接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接，然后客户端再做出应答，因此一共需要四次挥手。

## 客户端为什么需要在 TIME-WAIT 状态等待 2MSL 时间才能进入 CLOSED 状态？
按照常理，在网络正常的情况下，四个报文段发送完后，双方就可以关闭连接进入 CLOSED 状态了，但是网络并不总是可靠的，如果客户端发送的 ACK 报文段丢失，服务器在接收不到 ACK 的情况下会一直重发 FIN 报文段，这显然不是我们想要的。因此客户端为了确保服务器收到了 ACK，会设置一个定时器，并在 TIME-WAIT 状态等待 2MSL 的时间，如果在此期间又收到了来自服务器的 FIN 报文段，那么客户端会重新设置计时器并再次等待 2MSL 的时间，如果在这段时间内没有收到来自服务器的 FIN 报文，那就说明服务器已经成功收到了 ACK 报文，此时客户端就可以进入 CLOSED 状态了。

# TCP于UDP的区别
## TCP
TCP(Transmission Control Protocol) 是面向连接的、可靠的流协议。流就是不间断的数据结构，可以想象成排水管道中的水流。当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。
TCP为提供可靠性传输，实行 顺序控制 重发控制。此外还具备 流控制（流量控制） 拥塞控制 提高网络利用率等众多功能

## UDP
UDP(User Datagram Protocal) 是不具有可靠性的数据协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会达到。因此，应用有时会根据自己的需要进行重发处理。


# [CDN原理](https://segmentfault.com/a/1190000022205291)
## 没有CDN
当用户访问一个网站时，如果没有CDN，过程时这样的：
1. 浏览器将域名解析为IP地址，所以需要向本地DNS发出请求。
2. 本地DNS依次向 根服务器、顶级域名服务器、权限域名服务器发出请求，得到网站服务器的IP地址。
3. 本地DNS将IP地址发回给浏览器，浏览器向网站服务器IP地址发出请求并得到资源。

## 部署了CDN
如果用户访问的网站部署了CDN，过程时这样的：
1. 浏览器将域名解析为IP地址，所以需要向本地DNS发出请求。
2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统(Global Server Load Balance GSLB)的 IP 地址。
3. 本地DNS在想GSLB发出请求，GSLB的主要功能是根据本地DNS的IP地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统(SLB)，并将该SLB的IP地址作为结果返回给本地
4. 本地的DNS将SLB的IP地址发回给浏览器，浏览器向SLB发出请求。
5. SLB根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
6. 浏览器再根据SLB发回的地址重定向到缓存服务器。
7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。