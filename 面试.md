# mobx相关
通过监听数据（对象、数组）的属性变化，可以通过直接在数据上更改就能触发UI的渲染，从而做到MVVM、响应式、上手成本低、开发效率高

mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。

# redux vs mobx
* redux将数据保存在单一的store中；mobx将数据保存在分散的多个store中
* redux使用plain object保存数据，需要手动处理变化后的操作；mobx使用observable保存数据，数据变化后自动处理响应的操作
* redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
* mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
* mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易。

# reducer纯函数操作数组 为什么不push操作 （Immutability）

## 纯函数
* 返回值必须依赖于输入值，且输入值不变，返回值也不会变
* 它不会作出超出它本身作用域的影响

### 超出它本身作用域
* 直接修改数组或者对象的值
* 修改当前函数外的状态, 比如全局变量、window的属性
* API请求
* Math.random()

# React双向绑定

# 为什么每个react组件都需要import React from 'react'
因为打包工具是需要React.createElement这个方法把你写的jsx转化为虚拟DOM

# [React高阶组件](https://juejin.im/post/6844904050236850184)

高阶组件是一个函数，接收一个组件，然后返回一个新的组件

* react高阶组件能够让我们写出更易于维护的react代码
* 优雅地拆分组件
* 抽取重复代码，实现组件复用，常见场景：页面复用
* 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
* 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。

## 解决的问题

* 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合
* 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为
* 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担

# [Hook](https://github.com/brickspert/blog/issues/26)
## 优势
* 减少状态逻辑复用的风险
* 避免地狱式嵌套
* 让组件更容易理解
* 使用函数代替class

# [受控组件](https://reactjs.org/docs/forms.html#controlled-components) vs [非受控组件](https://reactjs.org/docs/uncontrolled-components.html)
受控组件：
在 HTML 中，表单元素（如input、 textarea 和 select）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

非受控组件：要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```
# react取消的三个生命周期函数
componentWillMount componentWillReceiveProps componentWillUpdate 容易被误用并滥用，可能会对异步渲染造成潜在的问题

# [react合成事件](https://juejin.cn/post/6897911576053940231)
react合成事件(SyntheticEvent)是react模拟原生DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器。兼容所有浏览器，拥有与原生浏览器原生事件相同的接口

# react Fiber
react内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点

# react组件间的通信方式
* 父组件向子组件通信 -- props传递
* 子组件向父组件通信 -- 父组件传递回调函数给子组件，子组件调用该回调函数，便可以向父组件通信
* 跨级组件之间的通信 -- 层层传递props  使用context对象
* 非嵌套组件间通信 -- 利用二者共同父组件的 context 对象进行通信 使用自定义事件的方式

# [Webpack是什么？解决了什么问题](https://www.bwrong.co/post/dev-tools03/)
Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler），当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
Webpack所指的模块不仅仅是JavaScript中的模块，通过Loader，它可以处理任意类型的资源。广义上来说，在Webpack看来，任意资源都是模块。

## Tree Shaking
它依赖于ES2015中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。
在现代 JavaScript 应用程序中，我们使用模块打包(如webpack或Rollup)将多个 JavaScript 文件打包为单个文件时自动删除未引用的代码。这对于准备预备发布代码的工作非常重要，这样可以使最终文件具有简洁的结构和最小化大小。

# [前端工程化](https://juejin.cn/post/6844903588553048077)



# [关键渲染路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path?hl=zh-cn)
优化关键渲染路径是指优先显示当前用户操作有关的内容。
浏览器到底是如何使用我们的HTML、CSS和JavaScript在屏幕上渲染像素的？
从收到HTML、CSS和JavaScript字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么-即**关键路径渲染**
通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间。此外，了解关键渲染路径还可以为构建高性能交互式应用打下基础。

## [构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn)
浏览器渲染页面需要先构建DOM和CSSOM树。因此，我们需要确保尽快地将HTML和CSS都提供给浏览器。
* 字节->字符->令牌->节点->对象模型
* HTML标记转换成文档对象模型（DOM）；CSS标记转换成CSS对象模型（CSSOM）。
* DOM和CSSOM是独立的数据结构。

1. **转换** 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如UTF-8）将他们转换成各个字符。
2. **令牌化** 浏览器将字符串转换成W3C HTML5标准规定的各种令牌，例如，“<html>”、“<body>”、以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。
3. **词法分析** 发出的令牌转换成定义其属性和规则的“对象”。
4. **DOM构建** 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。

# [DOM节点是如何与CSS样式关联的](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)
* DOM 树与 CSSOM 树合并后形成渲染树。
* 渲染树只包含渲染网页所需的节点。
* 布局计算每个对象的精确位置和大小。
* 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。

## 为构建渲染树，浏览器大体上完成了下列工作：
* 从 DOM 树的根节点开始遍历每个可见节点
    * 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
    * 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。
* 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
* 发射可见节点，连同其内容和计算的样式。

# 回流、重绘
## 回流
根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面正确的位置。回流一定会引起重绘，重绘不一定引发回流

引起回流的操作：
* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等）
* 元素字体大小变化
* 添加或者删除可见DOM元素
* 激活CSS伪类（:hover）
* 设置style属性
* 查询某些属性或者调用某些方法
  * width height margin padding border
  * display position overflow
  * clientWidth clientHeight clientTop clientLeft
  * offsetWidth offsetHeight offsetTop offsetLeft
  * scrollWidth scrollHeight scrollTop scrollLeft
  * scrollIntoView() scrollTo() getComputedStyle()
  * getBoundingClientRect() scrollIntoViewIfNeed()

## 重绘
当页面中元素样式的改变不影响他在文档流中的位置时，流入改变了字体颜色，浏览器会将样式赋予给元素并重新绘制的过程。
* color visibility text-decoration
* background-color background-image background-position background-repeat background-size
* outline outline-width outline-color outline-style
* border-style border-radius
* box-shadow

## 优化
* 减少DOM操作
* 采用更高效的API
  * 用querySelectorAll()替代getElementByXX()
  * 开启动画GPU加速，把渲染计算交给GPU
  * 用时间委托来减少事件处理器的数量
  * 使用框架、库  react vue的虚拟DOM
* 减少重排
* CSS及动画处理
  * 用更高效CSS3动画，通过类名控制动画，尽量避免直接操作DOM属性
  * 在动画的元素多嵌套一层div，尽量用绝对定位或者固定定位使其脱离文档流，再进行动画处理
  * 尽量在滚动的时候停止动画
  * 动画实现的速度选择

# 为什么es5的var 会是变量提升机制
当栈内存形成，JS代码自上而下执行之前，浏览器首先会把所有带“var”、“function”关键词的进行提前“声明（var）”或“定义（function）”。

# 全局变量的优缺点
优点：
* 全局可见，任何 一个函数或线程都可以读写全局变量-同步操作简单。                            
* 内存地址固定，读写效率比较高。
缺点：
* 全局变量存放在静态存储区，系统需要为其分配内存，一直到程序结束， 才会释放内存，这一点就局部变量的动态分配，随用随从栈中申请，用完（函数调用完毕）就释放。
* 影响函数的封装性能 降低函数的移值性


# JavaScript模块化

## 什么是模块化
优秀的作者把他们的书分成章节，优秀的程序员把他们的程序分成模块。好的模块是高度独立的，具有特定功能的，可以根据需要对它们进行修改，删除或添加，而不会破坏整个系统。

## 模块化的好处
* __命名空间__ 在 JavaScript 中，每个 JS 文件的接口都暴露在全局作用域中，每个人都可以访问它们，并且容易造成命名空间污染。模块化可以为变量创建私有空间来避免命名空间污染。
* __可重用性__ 将此代码模块化，则可以反复使用，且在需要修改时只需要修改此模块，而不需要在项目中的每个此代码处做修改。
* __可维护性__ 模块应该是独立的，一个设计良好的模块应尽可能减少对部分代码库的依赖，从而使其能够独立地删减和修改。当模块与其他代码片段分离时，更新单个模块要容易得多，还可以对每次修改的内容做版本管理。

# [web语义化](https://juejin.im/entry/6844903582274174984)
Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。语义化的web页面一方面可以让机器在更少的人类干预情况下收集并研究网页的信息，从而可以读懂网页的内容，然后将收集汇总的信息进行分析，结果为人类所用；另一方面它可以让开发人员读懂结构和用户以及屏幕阅读器（如果访客有视障）能够读懂内容。 简单来说就是利于 SEO，便于阅读维护理解。

* 正确的标签做正确的事情
* 页面内容结构化
* 无CSS样子时也容易阅读，便于阅读维护和理解
* 便于浏览器、搜索引擎解析。 利于爬虫标记、利于SEO


# setTimeout vs setInterval (结合Event loop)
**setTimeout** 经过指定时间后，把要执行的任务加入到Event Queue中，因为JavaScript是单线程，任务需要一个一个执行，如果前面的任务需要的时间太久，就会导致真正的延迟时间远大于指定时间。
**setInterval** 每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。一旦该回调函数执行时间超过了延迟时间，那么久完全看不出来时间间隔了。



# [跨域资源共享（CORS Cross-Origin Resource Sharing）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)
跨域资源共享是一种HTTP头机制，该机制通过允许服务器标示除了它自己以外的其它origin（域，协议和端口），这样浏览器可以访问加载这些资源。跨域资源共享还通过一种机制来检查服务器是否会允许要发送的真是请求，该机制通过浏览器发起一个到服务器托管的跨域资源的“预检”请求。在预检请求中，浏览器发送的头中标示有HTTP方法和真是请求中会用到的头。

## 简单请求
某些请求不会触发CORS预检请求，本文称这样的请求为“简单请求”。若请求满足所有下述条件，则该请求可视为“简单请求”：
* 使用下列方法之一
  * GET
  * HEAD
  * POST

* 除了被用户代理自动设置的首部字段（例如 Connection，User-Agent） 和在Fetch规范中定义为禁用首部名称的其他首部，允许认为设置的字段为Fetch规范定义的对CORS安全的首部字段集合。该集合为：
  * Accept
  * Accept-Language
  * Content-Language
  * Content-Type（需要额外追限制）
  * DPR
  * DownLink
  * Save-Data
  * Width

* Content-Type的值仅限于下列三者之一：
  * text/plain
  * multipart/form-data
  * application/x-www-form-urlencode

* 请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器；XMLHttpRequestUpload对象合一使用XMLHttpRequest.upload属性访问。
* 请求中没有使用ReadableStream对象

## 预检请求
与前述简单请求不同，“需预检的请求”要求必须首先使用OPTIONS方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生为预期的影响。


## HTTP响应首部字段
* Access-Control-Allow-Origin
* Access-Control-Expose-Headers
* Access-Control-Max-Age
* Access-Control-Allow-Credentials
* Access-Control-Allow-Methods
* Access-Control-Allow-Headers

## HTTP请求首部字段
* Origin
* Access-Control-Request-Method
* Access-Control-Request-Headers