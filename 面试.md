# mobx相关
通过监听数据（对象、数组）的属性变化，可以通过直接在数据上更改就能触发UI的渲染，从而做到MVVM、响应式、上手成本低、开发效率高

mobx 是更简单更方便更灵活的处理数据。 Store 是包含了 state 和 action。state 包装成一个可被观察的对象， action 可以直接修改 state，之后通过 Computed values 将依赖 state 的计算属性更新 ，之后触发 Reactions 响应依赖 state 的变更，输出相应的副作用 ，但不生成新的 state。

# redux vs mobx
* redux将数据保存在单一的store中；mobx将数据保存在分散的多个store中
* edux使用plain object保存数据，需要手动处理变化后的操作；mobx使用observable保存数据，数据变化后自动处理响应的操作
* redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改
* mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用
* mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易。

# reducer纯函数操作数组 为什么不push操作 （Immutability）

## 纯函数
* 返回值必须依赖于输入值，且输入值不变，返回值也不会变
* 它不会作出超出它本身作用域的影响

### 超出它本身作用域
* 直接修改数组或者对象的值
* 修改当前函数外的状态, 比如全局变量、window的属性
* API请求
* Math.random()

# React双向绑定

# [React高阶组件](https://juejin.im/post/6844904050236850184)

高阶组件是一个函数，接收一个组件，然后返回一个新的组件

* react高阶组件能够让我们写出更易于维护的react代码
* 优雅地拆分组件
* 抽取重复代码，实现组件复用，常见场景：页面复用
* 条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
* 捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。

## 解决的问题

* 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合
* 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为
* 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担

# Hook
## 优势
* 减少状态逻辑复用的风险
* 避免地狱式嵌套
* 让组件更容易理解
* 使用函数代替class

# [受控组件](https://reactjs.org/docs/forms.html#controlled-components) vs [非受控组件](https://reactjs.org/docs/uncontrolled-components.html)
受控组件：
在 HTML 中，表单元素（如input、 textarea 和 select）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。
我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('提交的名字: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          名字:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

非受控组件：要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。
```javascript
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```


# [Webpac是什么？解决了什么问题](https://www.bwrong.co/post/dev-tools03/)
Webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler），当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。
Webpack所指的模块不仅仅是JavaScript中的模块，通过Loader，它可以处理任意类型的资源。广义上来说，在Webpack看来，任意资源都是模块。

# [前端工程化](https://juejin.im/post/6844903588553048077)


# [DOM节点是如何与CSS样式关联的](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)
* DOM 树与 CSSOM 树合并后形成渲染树。
* 渲染树只包含渲染网页所需的节点。
* 布局计算每个对象的精确位置和大小。
* 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。

## 为构建渲染树，浏览器大体上完成了下列工作：
* 从 DOM 树的根节点开始遍历每个可见节点
    * 某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。
    * 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。
* 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。
* 发射可见节点，连同其内容和计算的样式。

# 为什么es5的var 会是变量提升机制
当栈内存形成，JS代码自上而下执行之前，浏览器首先会把所有带“var”、“function”关键词的进行提前“声明（var）”或“定义（function）”。

# 全局变量的优缺点
优点：
* 全局可见，任何 一个函数或线程都可以读写全局变量-同步操作简单。 
* 内存地址固定，读写效率比较高。
缺点：
* 全局变量存放在静态存储区，系统需要为其分配内存，一直到程序结束， 才会释放内存，这一点就局部变量的动态分配，随用随从栈中申请，用完（函数调用完毕）就释放。
* 影响函数的封装性能 降低函数的移值性


# JavaScript模块化

## 什么是模块化
优秀的作者把他们的书分成章节，优秀的程序员把他们的程序分成模块。好的模块是高度独立的，具有特定功能的，可以根据需要对它们进行修改，删除或添加，而不会破坏整个系统。

## 模块化的好处
* __命名空间__ 在 JavaScript 中，每个 JS 文件的接口都暴露在全局作用域中，每个人都可以访问它们，并且容易造成命名空间污染。模块化可以为变量创建私有空间来避免命名空间污染。
* __可重用性__ 将此代码模块化，则可以反复使用，且在需要修改时只需要修改此模块，而不需要在项目中的每个此代码处做修改。
* __可维护性__ 模块应该是独立的，一个设计良好的模块应尽可能减少对部分代码库的依赖，从而使其能够独立地删减和修改。当模块与其他代码片段分离时，更新单个模块要容易得多，还可以对每次修改的内容做版本管理。